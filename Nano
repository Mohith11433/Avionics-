#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
#include <Wire.h>
#include <MPU6050_tockn.h>
#include <Adafruit_BMP280.h>
#include <Servo.h>

RF24 radio(7, 8);
const byte address[6] = "ROCK1";

MPU6050 mpu6050(Wire);
Adafruit_BMP280 bmp;
Servo parachuteServo;
#define SERVO_PIN 9

// Auto-deployment settings
#define DEPLOYMENT_ALTITUDE 100.0
#define SERVO_DEPLOY_ANGLE 180
#define SERVO_RETRACT_ANGLE 0
#define MIN_APOGEE_ALTITUDE 50.0

// Flight state tracking
enum FlightState {
  STATE_LAUNCH_PAD,
  STATE_ASCENT,
  STATE_DESCENT,
  STATE_DEPLOYED
};

FlightState currentState = STATE_LAUNCH_PAD;
float maxAltitude = 0;
float previousAltitude = 0;
bool isDeployed = false;
int descentCount = 0;
float velocity = 0;
unsigned long lastTime = 0;

// Gyro calibration
float gyroX_offset = 0, gyroY_offset = 0, gyroZ_offset = 0;

struct RawData {
  uint32_t packetNum;
  float altitude;
  float pressure;
  float temperature;
  float accelX, accelY, accelZ;  // In m/sÂ² (Z â‰ˆ 9.8 at rest)
  float gyroX, gyroY, gyroZ;     // In Â°/s (calibrated)
  uint8_t flightState;
  uint8_t servoPosition;
  uint8_t deploymentTriggered;
  float verticalVelocity;
};

RawData data;
uint32_t counter = 0;

void calibrateGyro() {
  Serial.println("Calibrating gyro - KEEP ROCKET STILL!");
  delay(3000);
  
  float sumX = 0, sumY = 0, sumZ = 0;
  int samples = 100;
  
  for(int i = 0; i < samples; i++) {
    mpu6050.update();
    sumX += mpu6050.getGyroX();
    sumY += mpu6050.getGyroY();
    sumZ += mpu6050.getGyroZ();
    delay(20);
  }
  
  gyroX_offset = sumX / samples;
  gyroY_offset = sumY / samples;
  gyroZ_offset = sumZ / samples;
  
  Serial.print("Gyro offsets - X: ");
  Serial.print(gyroX_offset, 3);
  Serial.print(" | Y: ");
  Serial.print(gyroY_offset, 3);
  Serial.print(" | Z: ");
  Serial.println(gyroZ_offset, 3);
}

void setup() {
  Serial.begin(115200);
  Wire.begin();
  
  Serial.println("ðŸš€ NANO - ROCKET FLIGHT COMPUTER");
  Serial.println("================================");
  
  // Initialize servo
  parachuteServo.attach(SERVO_PIN);
  parachuteServo.write(SERVO_RETRACT_ANGLE);
  delay(1000);
  Serial.println("âœ… Servo: RETRACTED (0Â°)");
  Serial.print("ðŸ“ Auto-deploy at: ");
  Serial.print(DEPLOYMENT_ALTITUDE);
  Serial.println("m during descent");
  
  // Initialize MPU6050
  mpu6050.begin();
  delay(100);
  
  // Calibrate gyro
  calibrateGyro();
  
  // Initialize BMP280
  if (!bmp.begin(0x76)) {
    Serial.println("âŒ BMP280 not found!");
    while (1);
  }
  
  // Initialize radio
  radio.begin();
  radio.setPALevel(RF24_PA_MAX);
  radio.setDataRate(RF24_250KBPS);
  radio.setChannel(76);
  radio.setAutoAck(false);
  radio.setRetries(0, 0);
  radio.setPayloadSize(sizeof(data));
  radio.openWritingPipe(address);
  radio.stopListening();
  
  Serial.println("ðŸ“¡ Transmitting at 10Hz");
  Serial.println("================================");
  
  lastTime = millis();
}

void calculateVelocity() {
  unsigned long currentTime = millis();
  float dt = (currentTime - lastTime) / 1000.0;
  
  if (dt > 0) {
    velocity = (data.altitude - previousAltitude) / dt;
  }
  
  lastTime = currentTime;
}

void updateFlightState() {
  calculateVelocity();
  
  // Track maximum altitude
  if (data.altitude > maxAltitude) {
    maxAltitude = data.altitude;
  }
  
  // Detect descent (simplified)
  if (velocity < -1.0) {  // Descending faster than 1 m/s
    descentCount++;
    if (descentCount >= 5) {
      currentState = STATE_DESCENT;
    }
  } else {
    descentCount = 0;
  }
  
  // AUTO-DEPLOYMENT AT 100M
  if (!isDeployed && 
      currentState == STATE_DESCENT && 
      data.altitude <= DEPLOYMENT_ALTITUDE &&
      maxAltitude > MIN_APOGEE_ALTITUDE) {
    
    deployParachute();
  }
  
  previousAltitude = data.altitude;
}

void deployParachute() {
  Serial.println("\nðŸŽ¯ AUTO-DEPLOYMENT TRIGGERED!");
  Serial.print("Altitude: ");
  Serial.print(data.altitude, 1);
  Serial.println("m (descending through 100m)");
  
  // PHYSICAL SERVO MOVEMENT
  parachuteServo.write(SERVO_DEPLOY_ANGLE);
  isDeployed = true;
  currentState = STATE_DEPLOYED;
  
  Serial.println("âœ… PARACHUTE DEPLOYED! (Servo 180Â°)");
  
  // Blink LED
  pinMode(LED_BUILTIN, OUTPUT);
  for (int i = 0; i < 5; i++) {
    digitalWrite(LED_BUILTIN, HIGH);
    delay(100);
    digitalWrite(LED_BUILTIN, LOW);
    delay(100);
  }
}

void loop() {
  mpu6050.update();
  
  // Read REAL sensors
  data.packetNum = counter;
  data.altitude = bmp.readAltitude(1013.25);      // Real altitude
  data.pressure = bmp.readPressure() / 100.0;     // Real pressure
  data.temperature = bmp.readTemperature();       // Real temperature
  
  // Acceleration in m/sÂ² (multiply by 9.81 to fix library issue)
  data.accelX = mpu6050.getAccX() * 9.81;  // ~0 m/sÂ² at rest
  data.accelY = mpu6050.getAccY() * 9.81;  // ~0 m/sÂ² at rest
  data.accelZ = mpu6050.getAccZ() * 9.81;  // ~9.8 m/sÂ² at rest
  
  // Gyro with calibration offsets
  data.gyroX = mpu6050.getGyroX() - gyroX_offset;
  data.gyroY = mpu6050.getGyroY() - gyroY_offset;
  data.gyroZ = mpu6050.getGyroZ() - gyroZ_offset;
  
  // Update flight state
  updateFlightState();
  data.verticalVelocity = velocity;
  
  // Add state info
  data.flightState = currentState;
  data.servoPosition = isDeployed ? SERVO_DEPLOY_ANGLE : SERVO_RETRACT_ANGLE;
  data.deploymentTriggered = isDeployed ? 1 : 0;
  
  // Transmit
  radio.write(&data, sizeof(data));
  
  // Display
  if (counter % 10 == 0) {  // Every 1 second
    Serial.print("#");
    Serial.print(counter);
    Serial.print(" | Alt:");
    Serial.print(data.altitude, 1);
    Serial.print("m | Vel:");
    Serial.print(velocity, 1);
    Serial.print("m/s | AccZ:");
    Serial.print(data.accelZ, 1);
    Serial.print("m/sÂ² | Servo:");
    Serial.print(data.servoPosition);
    Serial.println("Â°");
  }
  
  counter++;
  delay(100);  // 10 Hz
}
